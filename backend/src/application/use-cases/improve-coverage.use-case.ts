import { Inject, Injectable, Logger } from '@nestjs/common';
import { promises as fs } from 'fs';
import * as path from 'path';
import type { IAIGenerator } from '../../domain/job/ai-generator.interface';
import { AI_GENERATOR_TOKEN } from '../../domain/job/ai-generator.interface';
import { ImprovementJob } from '../../domain/job/job.entity';
import type { IJobRepository } from '../../domain/job/job.repository.interface';
import { JOB_REPOSITORY_TOKEN } from '../../domain/job/job.repository.interface';
import { JobStatus } from '../../domain/job/job.value-objects';
import type { IRepositoryHost } from '../../domain/repository/repository-host.interface';
import { REPOSITORY_HOST_TOKEN } from '../../domain/repository/repository-host.interface';

async function fileExists(filePath: string): Promise<boolean> {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}

@Injectable()
export class ImproveCoverageUseCase {
  private readonly logger = new Logger(ImproveCoverageUseCase.name);

  constructor(
    @Inject(JOB_REPOSITORY_TOKEN)
    private readonly jobRepository: IJobRepository,
    @Inject(REPOSITORY_HOST_TOKEN)
    private readonly githubService: IRepositoryHost,
    @Inject(AI_GENERATOR_TOKEN) private readonly aiGenerator: IAIGenerator,
  ) {}

  async execute(jobId: string): Promise<void> {
    const job = await this.jobRepository.findById(jobId);
    if (!job) {
      this.logger.error(`Job ${jobId} not found`);
      return;
    }

    let localRepoPath = '';
    try {
      // 0. PERMISSIONS CHECK
      this.logger.log(`Checking permissions for ${job.repositoryUrl}...`);
      const hasPermissions = await this.githubService.checkPermissions(
        job.repositoryUrl,
      );
      if (!hasPermissions) {
        throw new Error(
          `Insufficient permissions to push to ${job.repositoryUrl}. Please check your GITHUB_TOKEN.`,
        );
      }

      // 1. CLONING
      await this.updateJobStatus(job, JobStatus.CLONING);
      localRepoPath = await this.githubService.cloneRepository(
        job.repositoryUrl,
      );

      // Default branch can vary, so we need to get it from the repository
      const baseBranch =
        await this.githubService.getDefaultBranch(localRepoPath);

      // 2. ANALYZING (Check if file exists)
      await this.updateJobStatus(job, JobStatus.ANALYZING);
      const fullFilePath = path.join(localRepoPath, job.filePath);
      if (!(await fileExists(fullFilePath))) {
        throw new Error(`File ${job.filePath} not found in repository`);
      }

      // Determine test file path - enforce .test.ts extension
      let newTestFilePath = `${job.filePath.replace(/\.tsx?$/, '')}.test.ts`;

      const possibleTestPaths = [
        path.join(localRepoPath, newTestFilePath),
        // We still check for existing .spec.ts in case we want to append, but our generator outputs .test.ts
        path.join(
          localRepoPath,
          `${job.filePath.replace(/\.tsx?$/, '')}.spec.ts`,
        ),
      ];

      for (const p of possibleTestPaths) {
        if (await fileExists(p)) {
          // If a file already exists, we enhance it
          newTestFilePath = path.relative(localRepoPath, p);
          break;
        }
      }

      // 3. GENERATING AI TESTS
      await this.updateJobStatus(job, JobStatus.GENERATING);
      // The Gemini CLI writes the file directly to disk at newTestFilePath
      await this.aiGenerator.generateTest(
        job.filePath,
        newTestFilePath,
        localRepoPath,
        job.targetCoverage,
      );

      // 4. PUSHING CHANGES — clean up validation artefacts as a secondary measure
      //    before the strict path-based git add.
      await this.updateJobStatus(job, JobStatus.PUSHING);
      const branchName = `improve-coverage-${job.id}`;

      for (const artefact of [
        'coverage',
        'tsconfig.validation.json',
        'jest.config.verification.js',
      ]) {
        await fs
          .rm(path.join(localRepoPath, artefact), {
            recursive: true,
            force: true,
          })
          .catch(() => {});
      }

      await this.githubService.commitAndPushChanges(
        localRepoPath,
        branchName,
        {}, // Empty fileMap — the AI already wrote the test file to disk
        `test: improve coverage for ${job.filePath}`,
        [newTestFilePath], // Stage ONLY the generated spec file
      );

      // 5. CREATING PR
      const prLink = await this.githubService.createPullRequest(
        job.repositoryUrl,
        branchName,
        `Improve test coverage for ${job.filePath}`,
        `This PR was automatically generated by AI to improve test coverage for \`${job.filePath}\`.`,
        baseBranch,
      );

      // 6. DONE
      await this.updateJobStatus(job, JobStatus.PR_CREATED, undefined, prLink);
    } catch (error) {
      this.logger.error(`Job ${jobId} failed:`, error);
      await this.updateJobStatus(job, JobStatus.FAILED, error.message);
    } finally {
      if (localRepoPath) {
        await this.githubService
          .cleanupLocalRepository(localRepoPath)
          .catch((e: any) => {
            this.logger.error(`Failed to cleanup ${localRepoPath}`, e);
          });
      }
    }
  }

  private async updateJobStatus(
    job: ImprovementJob,
    status: JobStatus,
    error?: string,
    prLink?: string,
  ) {
    job.updateStatus(status, error, prLink);
    await this.jobRepository.save(job);
    this.logger.log(`Job ${job.id} changed to ${status}`);
  }
}
